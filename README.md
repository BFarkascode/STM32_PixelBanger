# STM32_PixelBanger
Bare metal project to showcase a bitbang machine on a STM32_L053R8 nucleo board by driving an Adafruit neopixel strip.

## General description
I have a confession to make: I never had to do any bitbanging beforehand. As it goes, I always was in the comfortable situation where I could purposefully pick hardware that was fitting my demands or was otherwise restricted where tight timings generated by the MCU was just not an option.

Lately though, I have been running into issue with driving a system using a designated hardware solution and thus decided to set up my own custom bitbang machine that I could modify at my leisure…
…and what nicer thing to drive with a bitbang than an Adafruit neopixel, just to showcase that bitbang machine?

 As usual, I am not to use any of the official drive solutions, nor rely on HAL to do the heavy lifting.

## Bang ‘dat bit
What am I even talking about?

Bitbanging is the art of mimicking a signal without the appropriate hardware. This could be achieved either by modifying existing signal generation peripherals just as SPI or I2C, or by going fully manual. Practically, we will be flipping output states on a GPIO at a designated speed and period.

Now, usually when we are talking about flipping output states on a GPIO, we do it using delay functions which is fine as long as we are not looking for something speedy (say, frequency higher than 1 kHz). This isn’t a limitation we can work with, so we need something else to drive the GPIO.

Also, when we are generating digital signals such as USART, the duty cycle of the signal will be 50% (i.e. the HIGH state for one bit will be exactly as “long” as the LOW state) which may not be the case for every signal we intend to generate using bitbanging. A good example for such is the neopixel where the in-built pixel IC will recognise a LOW state as a duty cycle lower than 29% and a HIGH state as a duty cycle greater than 64%. We technically need to have a variable “delay” between high GPIO states which would be very hard to implement manually.

Luckily, we have a flexible PWM generator on pretty much all MCUs than can deal with these limitations, given they are calibrated well. (Just a sidenote, the widely used “SoftwareSerial” library in the classic Arduino UNO is uses exactly this method to mimic USART signals on alternative GPIO pins). Thus, if we managed to set the PWM up well, we should be able to have our bitbang machine and drive a strip of neopixels, no problem.

Right…?

## Previous relevant projects
I have already done a PWM generation project:
- STM32_ClockDriver
On how to set up bitbanging on an STM32, I recommend checking the official videos:
- Hands-On with STM32 Timers: Custom Signal Generation using PWM and DMA , Part 1 of 2 - YouTube
For driving the neopixels, I have checked the ControllersTech and the VFD collective projects below for guidelines:
- WS2812 LED with STM32 || PWM using DMA - YouTube
- https://www.thevfdcollective.com/blog/stm32-and-sk6812-rgbw-led

## To read
I suggest going through this to get a knack for bitbanging: 
[Custom Signal generation using PWM and DMA - STMicroelectronics Community](https://community.st.com/t5/stm32-mcus/custom-signal-generation-using-pwm-and-dma/ta-p/49809)

For the neopixels themselves, the official Adafruit site is golden:
https://learn.adafruit.com/adafruit-neopixel-uberguide/arduino-library-use

Don’t forget to check the datasheet of the neopixels too though (and be sure that you are using GRBW pixels to make this project work as-is)!

## Particularities
### Neopixels
Adafruit neopixels have a bunch of unicolor LEDs squashed into a small package with a driver IC. They can be daisy changed together, allowing a single MCU to drive multiple of them at the same time without the need of shift registers. What this means is that the first IC will cut off the first part of the incoming driver signal and then pass the rest on its output to the second pixel and so on, until either the strip or the drive signal ends. This one-line drive option is obviously a huge advantage, decreasing the footprint of any LED solution. To top it off, since the driver is local to each pixel, once we have fed it a value, it will keep that value until we overwrite it.

There is a flip side of this convenience though: the neopixel strip MUST be driven by a signal EXACTLY the designated frequency otherwise the sampling within the driver IC may miss a bit or two. Also, the signal has to be a variable duty cycle PWM signal since, as mentioned above, the driver IC will define a LOW state when it has sampled a PWM signal with a duty cycle of less than 29%. It will “read” a HIGH state coming in if the duty cycle is greater than 64%. A slight deviation is tolerated within these values, but a full-on “low” signal ( PWM duty cycle 0%)will not be read in as a LOW state, nor will a full “high” signal (PWM duty cycle 100%) as a HIGH. Given a proper HIGH or LOW state, the IC will then generate a PWM bit for the LEDs with a sequence of GRBW (or GRB, or RGB depending on model). Lastly, there must be no delay between the individual pixel values within the signal, the strip’s drive signal must be completely continuous.

Speaking of models, we can have a GRBW neopixel, which has 4 LEDs in one pixel (colours plus white) and a GRB/RGB neopixel, which has 3. We may also have pixels that demand a designated drive frequency of 400 kHz, while others, 800 kHz.

All in all, the GRBW neopixel we will be using demands a 800 kHz signal with a variable duty cycle feeding it 32 variable cycles that will be converted in 32-bit PWM data for the 4 LEDs. It needs to be 32 bits since we have 4 colours/LEDs, not 3. We will also have the colour data encoded as green-red-blue-white since the pixel is GRBW. Other types might have a different colour sequence.

Of note, pixel strip signals should be separated by at least 80 us of blank signal (so NOT a LOW state, a blank 0% duty cycle PWM state) to indicate to the strip that the signal is over.

###Pain on many levels
As discussed above, the bitbanging signal we are to generate for the neopixels will need to be very accurate and relatively fast (a frequency of only 1/40 of the speed of our MCU running at 32 MHz). As such, we will be relying on the DMA in a rather complex fashion.

This introduces multiple difficulties that are worth to touch upon.

####Why DMA?
Something that eluded me – since nobody touched upon within the projects I have checked – was the need to use a DMA. 1/40 slower than the clocking frequency of the L053 is fast, but not that fast that we can’t just do it “by hand”, using IRQs and while blocks, especially if we aren’t doing anything else with our MCU. We should be able to trigger the GPIO fast enough without a DMA…

…in theory. In reality, there was a slight delay (for 800 kHz signal frequency, we dropped down to 769 kHz) every time the PWM period was updated which, eventually, added up into a rather significant delay. For a low number of pixels, this was fine, but if the actual purpose of the project was to have a reliable bitbang machine with pitch-perfect signals, this was a no-go. Just to give an estimate, writing to the 8th neopixel in the strip was actually changing the brightness on the 9th one when this approach was used.

Thus, it became necessary to use DMA to meet the signal timing.

#### A cautionary tale on non-matching bit depths 
It took me a lot of time to figure this one out, but the signal output, the DMA and the TIM peripherals DO NOT NECESSARILY use the same bit depth. This means that even though a register’s address is 32-bit deep, the register itself may only allow 16-bits to be loaded into it (see CCR1 register in TIM) and the PWM value we intend to generate may only be 8 bits. As such, it is absolutely crucial to align the bit depth properly, otherwise bytes of information might be lost or captured multiple times.

Let’s image this problem in terms of pointers. When we use DMA, we define pointers that will be stepped through the memory depending on the size of the pointer. Now, if we have a read pointer of 8-bits while loading a register of 16-bits, then we will load the 16-bit register TWICE (once for MSB and once for LSB) before the register’s value will be published (registers are published when they are considered “full”). This is obviously a mistake. Luckily, the DMA can do the transition automatically, where we can tell it to read in an 8-bit value but publish it as 16-bits. It will “fill in” the unused parts with 0-s for us.

For our case – running the neopixels – the output (on an atomic level) will need to be a 8-bit deep PWM duty cycle. Yet, the CCR1 register’s address is 32-bits which stores ONLY 16-bits of data. Thus, assuming a uint8_t array as input, the DMA has to have a memory side read depth of 8 bits and a peripheral side write depth of 32 bits.

It must be kept in mind that the right amount of bits must be supplied to the right place, otherwise the outcome will be chaotic.

Also, don’t forget to set the DMA up from memory to peripheral. It won’t work in the other direction, no matter how much you scream at it…sigh…

#### Timing complexity, buffering complexity
Unlike previous projects, where we were running one “autonomous system” (peripheral) in parallel with the MCU, we will be running two of them (the DMA and the TIM) in an interconnected fashion. What I mean by that is that both the TIM and the DMA will just do its thing without any supervision once we started them up. Since the TIM will need to be updated by the DMA, the timing between these two elements must be perfectly mint.

Unfortunately, exactly because of how “hidden” the inner workings of the peripheral are to the MCU, it is difficult to figure out the exact sequence of what is going on. When is the DMA loading the values into the TIM, for instance? Is it safe to turn off the TIM PWM channel before or after the DMA? Do we even need to reset the DMA or we can let it run in circular mode? Do we need to stop the TIM or it can stay enabled? On the myriad of ways the DMA can be triggered by the TIM (on update, on overrun/underrun, on output compare or on input compare), exactly which one will allow us to daisy chain the execution for a continuous signal output?

To make things worse, the TIM has multiple buffers to allow it to run smoothly. This means that even if we trigger at the right place, these buffers need to be update immediately, otherwise the TIM will clock over with the wrong values, introducing signal fault or delay (and thus crash the precision of the signal).

What I had to rely on trial and error to figure out exactly in what sequence the TIM and the DMA would need to be started as well as where the DMA should be triggered as well as what buffers had to be zeroed out when the trigger is tripped.

Eventually, my solution for starting up the DMA-TIM combination ended up being different than what ST is suggesting in the refman (page 995). Their sequence introduced a fake set of bits on the start.

At the stop of the signal, I had to leave a singular fake period at the end since by the time DMA TC has triggered, the peripheral has already loaded in a new value into the TIM buffer to generate the next PWM period. Luckily, this fake period will always be the same as the very last bit of actual information we want to send, thus making it unlikely to bug out whatever we intend to drive with the bitbang machine in the future.

## User guide
The code works fine and reliably, tested with an 8 pixel and a 24 pixel GRBW neopixel strip.

### Rundown
Just a quick rundown of what is going on, assuming a constant source matrix:
1) We load a row of data points from the source matrix (4 times 8 bits for a 32 bit bitbang machine).
2) We convert each of these bits each into 1-byte PWM values (3 for a LOW, 6 for a HIGH).
3) We load these 32 bytes in the 2x32 byte ping-pong buffer (to the MSB row if we had DMA trigger on a half point, the LSB row if we triggered on the TC).
4) The DMA loads the TIM and generate the appropriate output signal. In this project, each 32 byte read from the ping-pong buffer will drive one neopixel.
5) The DMA will run on the ping-pong buffer in a circular fashion until the readout for the very last two pixels is to start.
6) The DMA stops after the last two 32-bytes – the last two pixels – are sent.
7) We restart from the first row of the source matrix.

### Memory management
We can’t quite store all the data of the signal within the MCU, it would take up too much memory. The signal PWM source will already be 4 * 8 * 1 bytes = 32 bytes (4 colours, 8 values/bits on the output if the pixel drive IC, 1 byte to generate each bit using a separate PWM duty cycle), just for 1 GRBW pixel, image when you have dozens of them…

What we can do is run a ping-pong buffer, updating one side of the buffer with the fresh pixel values while reading the other part out with the DMA. This will double the DMA transfer width from 32 to 64 and half the signal repetition from 8 to 4 (in case of 8 pixel strip). We will store the information on what the output signal should be in a uint8_t two-dimensional source matrix where the row will represent the pixel (0th row, 1st pixel!) and the columns, the designated PWM values.

We will do the loading of the ping-pong buffer (both MSB and LSB rows) within the IRQ handler function itself, which is NOT a good practice, but since we finish the entire update process in 20 us, we can get away with it. The pre-loading must be done though, otherwise the DMA would not be able to run in a circular fashion.

Speaking of circularity, the processing (the DMA’s circularity) must be stopped before the last round, otherwise the DMA will keep on loading the TIM. We simply can’t turn it off fast enough using IRQs otherwise. This is done within the IRQ.

#### About colours
As discussed above, in every and each neopixel, we will have multiple LEDs whose brightness will be controlled by the PWM. This means that when we wish to mix a colour up on a pixel, we will be moving in 3-dimensional space. This becomes particularly complicated from an algorithm point of view when we wish to implement dynamic change of the output colours.

At the same time, the perceived brightness of an LED is not linear in regards of the PWM value we are feeding it. I have implemented a gamma correction to deal with this issue within the “main.h” header file, just as I did in the STM32_ClockDriver project before.
All in all, it would be a complete arts and creativity project to track all the colours and then come up with an algorithm that could roam in that colourspace reliably. Since the purpose of this project has been to showcase bitbanging and not to drive the neopixels perfectly, I have decided not to indulge myself with too complex colour generation algorithms. I did write a few simple transition and colour animations that are put being “#ifdef” sections.

#### DMAR & DCR
I want to touch upon this a bit since while reverse engineering the HAL solution, I saw this register in the TIM was filled up. Unfortunately, there is barely any information on its use within the refman, even though it clearly concerns the DMA.
From what I take of it, the DMAR register is an alternative control system from the DMA when using TIM, activated by defining the DMAR register as the peripheral address for the DMA instead of, say, the CCR1 register.

Usually, what we do when we set the DMA is that we define a read pointer start position and a write pointer start position and then tell the DMA to step these with a size defined by the appropriate DMA CCR register bits. What the DMAR/DCR does – seemingly - is that it takes the control away from the DMA and give it to the TIM. Then we can tell the DMA from where to start writing (DBA bits in DCR) and for many burst transfers we want to do (DBL in DCR). The burst will then update a whole chunk of the TIM registers (refman page 540 examples updating all 4 CCR registers).

Anyway, through trial and error, I figured out that we won’t need the DMAR control for a single direct DMA access and this HAL suggestion was be removed from my bare metal solution.

#### Debugging difficulties
In general, it is a non-trivial work to figure out, how the DMA is interfacing with the output and the peripheral. Here, for instance, it was particularly challenging to harmonize the neopixel update dynamics, both within a strip and between strip publication (i.e. dynamic strip update). We have the DMA reading out from the 2x32 bit PWM buffer, we also have the data buffer holding the values we wish to publish and then the PWM doing its thing, plus us loading the pixel PWM buffer. We have multiple elements that must be updated in the right sequence and direction, otherwise we will not have the right pixel data published at the right pixel position. We also must keep in mind that any “for” type loop in an array would need to manually “loop back” to the first/last element (i.e., first pixel’s value must be copied to the last pixel) or we lose data.

With all that going on, the neopixels demand a non-interrupted, analogue signal, so we can’t use the usual debugging tools of the IDE: it would simply not result in an output if we stop mid signal generation. Similarly-similarly, past two pixels, the signal is going to be too long to be captured with a normal oscilloscope.

As such, only trial and error debugging can be used without a signal analyzer to figure out if there are any issues.

#### Words of advice
1)	If we are updating the source matrix on the fly to add effects to the neopixel strip (i.e., we want the bitbang signal to be dynamically changing between two publishing), it must be done in a way that it will not clash with the timing of the bitbang machine.
2)	We are running multiple blocking delay functions to time the output, which could be removed. It must be kept in mind though that each strip must be followed by a 80 us or longer “blank” signal, otherwise the driver IC will not know that it can light the strip up. That delay should only be removed with extreme cautions.
3)	It is possible to drive less pixels in the strip than what is available, though I advise against it. I think it is best to give a value to the unused pixels (a value of 0), not forgetting that a pixel left floating may not remain off in a noisy environment. After all, a pixel being not turned “on” beforehand by the published signal is not the same as a pixel that has received 32-bits worth of “LOW”.
4)	All functions need the pixel strip to have at least 2 pixels in it, otherwise they won’t work. This is due to size of the ping-pong buffer, which holds the value of two pixels.
5)	When generating a dynamic output, after each matrix update, the ping-pong should always be preloaded with the new matrix’ first two elements.
6)	Loading the ping-pong buffer the wrong way around (MSB on TC, LSB on half way point) will lead to overrun where we end up changing the 32 byte PWM value we intend to publish while we are changing/updating it, nullifying the purpose of using a pin-pong buffer the first place (we publish one side while we change the other).
7)	Please be aware that the source matrix row number needs to match the number of pixels in the strip.

## Conclusion
This was a significantly more complex project that I initially envisioned, but it ended up providing me with a reliable 32-bit bitbang machine that I could modify at my leisure (frequency, duty cycle, signal length/repetition and dynamic values).
